"""
signal_server.py — WebSocket Signal Server for ERC-8004 Trading Agent.

Broadcasts live trade signals to connected clients every 5 seconds using
asyncio WebSockets. Signals are generated by the mesh coordinator and
include confidence, direction, and agent identity metadata.

Usage (standalone):
    python3 -m asyncio agent/signal_server.py

    Or embed in asyncio app:
        server = SignalServer(coordinator=MeshCoordinator())
        await server.start()
"""

from __future__ import annotations

import asyncio
import json
import random
import time
from dataclasses import asdict, dataclass, field
from enum import Enum
from typing import Optional, Set

try:
    import websockets
    HAS_WEBSOCKETS = True
except ImportError:
    HAS_WEBSOCKETS = False

from mesh_coordinator import MeshCoordinator, VoteAction


# ─── Signal Types ─────────────────────────────────────────────────────────────

class SignalType(str, Enum):
    BUY       = "BUY"
    SELL      = "SELL"
    HOLD      = "HOLD"
    REBALANCE = "REBALANCE"


PROTOCOLS = ["Aave", "Uniswap", "Compound", "Curve", "Balancer", "GMX", "dYdX"]


# ─── Signal Data Class ────────────────────────────────────────────────────────

@dataclass
class TradeSignal:
    """A live trade signal broadcast via WebSocket."""
    timestamp: float
    signal_type: str           # SignalType value
    protocol: str
    direction: str             # "LONG" | "SHORT" | "NEUTRAL"
    confidence: float          # 0.0 – 1.0
    agent_id: str
    sequence: int = 0
    mesh_consensus: bool = False
    weighted_confidence: float = 0.0

    def to_json(self) -> str:
        return json.dumps({
            "timestamp": self.timestamp,
            "signal_type": self.signal_type,
            "protocol": self.protocol,
            "direction": self.direction,
            "confidence": round(self.confidence, 4),
            "agent_id": self.agent_id,
            "sequence": self.sequence,
            "mesh_consensus": self.mesh_consensus,
            "weighted_confidence": round(self.weighted_confidence, 4),
        })

    @classmethod
    def from_dict(cls, d: dict) -> "TradeSignal":
        return cls(
            timestamp=d["timestamp"],
            signal_type=d["signal_type"],
            protocol=d["protocol"],
            direction=d["direction"],
            confidence=d["confidence"],
            agent_id=d["agent_id"],
            sequence=d.get("sequence", 0),
            mesh_consensus=d.get("mesh_consensus", False),
            weighted_confidence=d.get("weighted_confidence", 0.0),
        )


# ─── Signal Generator ─────────────────────────────────────────────────────────

class SignalGenerator:
    """
    Generates synthetic trade signals using the mesh coordinator.

    Produces a mix of BUY/SELL/HOLD/REBALANCE signals with varying
    confidence levels, cycling through available protocols.
    """

    def __init__(
        self,
        coordinator: Optional[MeshCoordinator] = None,
        agent_id: str = "signal_server_v1",
    ) -> None:
        self.coordinator = coordinator or MeshCoordinator()
        self.agent_id = agent_id
        self._sequence = 0
        self._protocol_idx = 0

    @property
    def sequence(self) -> int:
        return self._sequence

    def next_signal(self) -> TradeSignal:
        """Generate the next trade signal using mesh consensus."""
        self._sequence += 1
        protocol = PROTOCOLS[self._protocol_idx % len(PROTOCOLS)]
        self._protocol_idx += 1

        # Synthetic price/size for signal generation
        price = random.uniform(0.50, 3500.0)
        size = random.uniform(1.0, 10.0)
        portfolio_value = 10_000.0

        # Use mesh to get consensus
        from credora_client import CredoraRatingTier
        grade = random.choice([
            CredoraRatingTier.AAA, CredoraRatingTier.AA, CredoraRatingTier.A,
            CredoraRatingTier.BBB, CredoraRatingTier.BB,
        ])
        side = random.choice(["BUY", "SELL"])
        consensus = self.coordinator.evaluate(
            side=side,
            size=size,
            price=price,
            portfolio_value=portfolio_value,
            protocol_grade=grade,
            edge=random.uniform(0.02, 0.12),
        )

        # Map consensus to signal
        if not consensus.consensus_reached:
            signal_type = SignalType.HOLD
            direction = "NEUTRAL"
            confidence = random.uniform(0.1, 0.4)
        else:
            action = consensus.final_action
            if action == VoteAction.BUY:
                signal_type = SignalType.BUY
                direction = "LONG"
            elif action == VoteAction.SELL:
                signal_type = SignalType.SELL
                direction = "SHORT"
            elif action == VoteAction.HOLD:
                signal_type = SignalType.HOLD
                direction = "NEUTRAL"
            else:
                signal_type = SignalType.REBALANCE
                direction = "NEUTRAL"

            # Occasional rebalance override
            if self._sequence % 7 == 0:
                signal_type = SignalType.REBALANCE
                direction = "NEUTRAL"

            confidence = min(1.0, consensus.approval_ratio)

        return TradeSignal(
            timestamp=time.time(),
            signal_type=signal_type.value,
            protocol=protocol,
            direction=direction,
            confidence=confidence,
            agent_id=self.agent_id,
            sequence=self._sequence,
            mesh_consensus=consensus.consensus_reached,
            weighted_confidence=getattr(consensus, "approval_ratio", confidence),
        )

    def generate_batch(self, n: int) -> list[TradeSignal]:
        """Generate n signals in sequence."""
        return [self.next_signal() for _ in range(n)]


# ─── WebSocket Signal Server ───────────────────────────────────────────────────

class SignalServer:
    """
    AsyncIO WebSocket server that broadcasts live trade signals.

    Clients connect and immediately receive the current state, then
    continue receiving signals every `broadcast_interval` seconds.
    """

    def __init__(
        self,
        host: str = "localhost",
        port: int = 8765,
        broadcast_interval: float = 5.0,
        coordinator: Optional[MeshCoordinator] = None,
        agent_id: str = "signal_server_v1",
    ) -> None:
        self.host = host
        self.port = port
        self.broadcast_interval = broadcast_interval
        self.generator = SignalGenerator(coordinator=coordinator, agent_id=agent_id)
        self._clients: Set = set()
        self._running = False
        self._server = None
        self._broadcast_count = 0
        self._last_signal: Optional[TradeSignal] = None

    @property
    def connected_clients(self) -> int:
        return len(self._clients)

    @property
    def broadcast_count(self) -> int:
        return self._broadcast_count

    @property
    def last_signal(self) -> Optional[TradeSignal]:
        return self._last_signal

    async def _handler(self, websocket, path: str = "/") -> None:
        """Handle a new client connection."""
        self._clients.add(websocket)
        try:
            # Send welcome + last signal immediately
            welcome = {
                "type": "connected",
                "agent_id": self.generator.agent_id,
                "clients": self.connected_clients,
                "timestamp": time.time(),
            }
            await websocket.send(json.dumps(welcome))
            if self._last_signal:
                await websocket.send(self._last_signal.to_json())
            # Keep alive until client disconnects
            await websocket.wait_closed()
        finally:
            self._clients.discard(websocket)

    async def _broadcast_loop(self) -> None:
        """Generate and broadcast signals to all connected clients."""
        while self._running:
            await asyncio.sleep(self.broadcast_interval)
            if not self._clients:
                continue
            signal = self.generator.next_signal()
            self._last_signal = signal
            self._broadcast_count += 1
            msg = signal.to_json()
            disconnected = set()
            for ws in list(self._clients):
                try:
                    await ws.send(msg)
                except Exception:
                    disconnected.add(ws)
            self._clients -= disconnected

    async def start(self) -> None:
        """Start the WebSocket server and broadcast loop."""
        if not HAS_WEBSOCKETS:
            raise RuntimeError("websockets package not installed")
        self._running = True
        self._server = await websockets.serve(self._handler, self.host, self.port)
        asyncio.create_task(self._broadcast_loop())

    async def stop(self) -> None:
        """Stop the server gracefully."""
        self._running = False
        if self._server:
            self._server.close()
            await self._server.wait_closed()

    def get_status(self) -> dict:
        """Return current server status."""
        return {
            "running": self._running,
            "host": self.host,
            "port": self.port,
            "connected_clients": self.connected_clients,
            "broadcast_count": self._broadcast_count,
            "broadcast_interval": self.broadcast_interval,
            "last_signal": self._last_signal.to_json() if self._last_signal else None,
        }


# ─── Entrypoint ───────────────────────────────────────────────────────────────

async def main() -> None:
    server = SignalServer()
    await server.start()
    print(f"Signal server running on ws://{server.host}:{server.port}")
    print("Press Ctrl+C to stop.")
    try:
        await asyncio.Future()  # run forever
    except KeyboardInterrupt:
        await server.stop()


if __name__ == "__main__":
    asyncio.run(main())
